<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Competitive Monitor - 3D Force Graph</title>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0f;
            color: #eee;
            overflow: hidden;
        }
        
        /* Mobile controls styling */
        #toggle-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(20, 20, 30, 0.95);
            padding: 12px 16px;
            border-radius: 25px;
            border: 1px solid #333;
            cursor: pointer;
            z-index: 101;
            color: #00ff88;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        
        /* Desktop collapse button */
        .collapse-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: transparent;
            border: none;
            color: #00ff88;
            cursor: pointer;
            font-size: 16px;
            padding: 5px;
        }
        
        .collapse-btn:hover {
            color: #00ff88;
            opacity: 0.8;
        }
        
        @media (max-width: 768px) {
            #toggle-controls {
                display: block;
            }
            
            #controls {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                transform: translateY(100%);
                transition: transform 0.3s ease;
                border-radius: 20px 20px 0 0;
                max-height: 60vh;
                width: auto;
                margin: 0;
            }
            
            #controls.open {
                transform: translateY(0);
            }
            
            #legend {
                top: 60px !important;
                right: 10px !important;
            }
        }
        
        @media (min-width: 769px) {
            #controls.collapsed {
                width: auto;
                padding: 10px;
            }
            
            #controls.collapsed .control-content {
                display: none;
            }
            
            #controls.collapsed h4 {
                margin: 0;
                display: inline-block;
            }
            
            #legend.shifted {
                right: 50px !important;
            }
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(20, 20, 30, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            max-width: 350px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        #stats {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(20, 20, 30, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #333;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(20, 20, 30, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            z-index: 100;
            width: 280px;
            backdrop-filter: blur(10px);
            max-height: 90vh;
            overflow-y: auto;
            transition: all 0.3s ease;
        }
        
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        
        .control-group:last-child {
            border-bottom: none;
        }
        
        label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            color: #aaa;
            font-size: 12px;
        }
        
        h3 {
            margin: 0 0 10px 0;
            color: #00ff88;
        }
        
        h4 {
            margin: 0 0 10px 0;
            color: #00ff88;
            font-size: 14px;
        }
        
        .green { color: #00ff88; }
        .stat-item { margin: 5px 0; }
        
        #legend {
            position: absolute;
            top: 10px;
            right: 310px;
            background: rgba(20, 20, 30, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            backdrop-filter: blur(10px);
            max-width: 200px;
            font-size: 12px;
            transition: right 0.3s ease;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        @media (max-width: 1200px) {
            #legend {
                max-width: 150px;
                font-size: 11px;
            }
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff88;
            font-size: 18px;
            z-index: 1000;
        }
        
        .slider-value {
            font-weight: bold;
            color: #00ff88;
            min-width: 45px;
            text-align: right;
        }
        
        select {
            background: rgba(0, 0, 0, 0.5);
            color: #eee;
            border: 1px solid #333;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        input[type="text"] {
            background: rgba(0, 0, 0, 0.5);
            color: #eee;
            border: 1px solid #333;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            width: 100%;
            margin-top: 5px;
        }
        
        .info-text {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
            font-style: italic;
        }
        
        .checkbox-group {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 8px;
            margin-top: 8px;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            margin: 4px 0;
            font-size: 12px;
        }
        
        .checkbox-item input[type="checkbox"] {
            margin-right: 8px;
        }
        
        .checkbox-item span {
            flex: 1;
        }
        
        .checkbox-count {
            color: #666;
            font-size: 10px;
            margin-left: 4px;
        }
        
        .select-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        .select-buttons button {
            flex: 1;
            padding: 4px 8px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            color: #00ff88;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .select-buttons button:hover {
            background: rgba(0, 255, 136, 0.2);
        }
        
        /* Context menu styling */
        #context-menu {
            display: none;
            position: fixed;
            background: rgba(20, 20, 30, 0.95);
            border: 1px solid #00ff88;
            border-radius: 8px;
            padding: 8px 0;
            min-width: 200px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        
        .context-menu-item {
            padding: 10px 20px;
            cursor: pointer;
            color: #eee;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .context-menu-item:hover {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }
        
        .context-menu-separator {
            height: 1px;
            background: #333;
            margin: 5px 0;
        }
        
        .context-menu-header {
            padding: 10px 20px;
            color: #00ff88;
            font-weight: bold;
            border-bottom: 1px solid #333;
            margin-bottom: 5px;
        }
    </style>
    <script src="https://unpkg.com/three@0.152.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three-spritetext@1.8.0/dist/three-spritetext.min.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.0/dist/3d-force-graph.min.js"></script>
</head>
<body>
    <div id="loading">Loading AI Competitive Intelligence Graph...</div>
    
    <div id="info" style="display: none;">
        <h3>ðŸ§  AI Competitive Monitor</h3>
        <div id="node-info">
            <strong>Controls:</strong><br>
            â€¢ Left-click + drag = Rotate view<br>
            â€¢ Right-click + drag = Pan view<br>
            â€¢ Scroll = Zoom in/out<br>
            â€¢ Click node = Center camera<br>
            â€¢ Right-click node = Show context menu
        </div>
    </div>
    
    <div id="stats" style="display: none;">
        <div class="stat-item">Monitoring: <span id="company-count" class="green">--</span> companies</div>
        <div class="stat-item">URLs: <span id="url-count" class="green">--</span></div>
        <div class="stat-item">Nodes: <span id="node-count" class="green">--</span></div>
        <div class="stat-item">Links: <span id="link-count" class="green">--</span></div>
    </div>
    
    <div id="legend" style="display: none;">
        <h4>â–¼ Legend</h4>
        <div class="info-text">Node Types</div>
        <div id="legend-content"></div>
    </div>
    
    <div id="controls" style="display: none;">
        <button class="collapse-btn" onclick="toggleControlsCollapse()">â—€</button>
        <h4>Controls</h4>
        
        <div class="control-content">
            <div class="control-group">
                <h4 style="font-size: 12px; margin-bottom: 8px;">View Mode</h4>
                <label>
                    Color By
                    <select id="view-mode">
                        <option value="entity-type">Entity Type</option>
                        <option value="interest">Interest Analysis</option>
                        <option value="activity">Activity Level</option>
                        <option value="connections">Connection Strength</option>
                    </select>
                </label>
                <div class="info-text">
                    â€¢ Entity Type: Colors by company type<br>
                    â€¢ Interest: Strategic importance (red=high)<br>
                    â€¢ Activity: URL count (red=many)<br>
                    â€¢ Connections: Node connectivity
                </div>
            </div>
            
            <div class="control-group">
                <h4 style="font-size: 12px; margin-bottom: 8px;">Visual Settings</h4>
                <label>
                    Show Links
                    <input type="checkbox" id="toggle-links" checked>
                </label>
                <label>
                    Show Labels
                    <input type="checkbox" id="toggle-labels" checked>
                </label>
                <label>
                    Show Particles
                    <input type="checkbox" id="toggle-particles" checked>
                </label>
                <label>
                    Thin Lines Mode
                    <input type="checkbox" id="toggle-thin-lines">
                </label>
            </div>
            
            <div class="control-group">
                <h4 style="font-size: 12px; margin-bottom: 8px;">Camera Controls</h4>
                <button onclick="centerView()" style="width: 100%; padding: 8px; background: rgba(0, 255, 136, 0.1); border: 1px solid #00ff88; color: #00ff88; border-radius: 4px; cursor: pointer; margin-bottom: 10px;">Center View</button>
            </div>
            
            <div class="control-group">
                <h4 style="font-size: 12px; margin-bottom: 8px;">Graph Physics</h4>
                <label>
                    Force Strength
                    <input type="range" id="force-strength" min="-1000" max="-50" value="-300" step="50">
                    <span class="slider-value" id="force-value">-300</span>
                </label>
                <label>
                    Link Distance
                    <input type="range" id="link-distance" min="10" max="200" value="30" step="10">
                    <span class="slider-value" id="distance-value">30</span>
                </label>
            </div>
            
            <div class="control-group">
                <h4 style="font-size: 12px; margin-bottom: 8px;">Filter by Type</h4>
                <div class="select-buttons">
                    <button onclick="selectAllTypes()">Select All</button>
                    <button onclick="selectNoneTypes()">Select None</button>
                </div>
                <div class="checkbox-group" id="type-filters">
                    <!-- Checkboxes will be populated here -->
                </div>
            </div>
            
            <div class="control-group">
                <h4 style="font-size: 12px; margin-bottom: 8px;">Search</h4>
                <input type="text" id="search-input" placeholder="Search companies...">
            </div>
        </div>
    </div>
    
    <button id="toggle-controls">â˜° Controls</button>
    <div id="3d-graph"></div>
    
    <!-- Context Menu -->
    <div id="context-menu">
        <div class="context-menu-header" id="context-menu-title">Node Name</div>
        <div class="context-menu-item" onclick="focusOnContextNode()">Show Only This & Connected</div>
        <div class="context-menu-item" onclick="centerOnContextNode()">Center Camera Here</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="hideContextMenu()">Cancel</div>
    </div>

    <script>
        // Global variables and functions for UI
        let selectedTypes = new Set();
        let contextMenuNode = null;
        
        function hideContextMenu() {
            document.getElementById('context-menu').style.display = 'none';
            contextMenuNode = null;
        }
        
        function focusOnContextNode() {
            if (contextMenuNode && window.focusOnNode) {
                window.focusOnNode(contextMenuNode);
            }
            hideContextMenu();
        }
        
        function centerOnContextNode() {
            if (contextMenuNode && window.Graph) {
                const distance = 300;
                const distRatio = 1 + distance/Math.hypot(contextMenuNode.x, contextMenuNode.y, contextMenuNode.z);
                window.Graph.cameraPosition(
                    { x: contextMenuNode.x * distRatio, y: contextMenuNode.y * distRatio, z: contextMenuNode.z * distRatio },
                    contextMenuNode,
                    1000
                );
            }
            hideContextMenu();
        }
        
        // Hide context menu when clicking elsewhere
        document.addEventListener('click', (e) => {
            if (!e.target.closest('#context-menu')) {
                hideContextMenu();
            }
        });
        
        function toggleControlsCollapse() {
            const controls = document.getElementById('controls');
            const legend = document.getElementById('legend');
            const btn = controls.querySelector('.collapse-btn');
            
            controls.classList.toggle('collapsed');
            legend.classList.toggle('shifted');
            
            btn.textContent = controls.classList.contains('collapsed') ? 'â–¶' : 'â—€';
        }
        
        function selectAllTypes() {
            selectedTypes.clear();
            document.querySelectorAll('#type-filters input[type="checkbox"]').forEach(cb => {
                cb.checked = true;
                selectedTypes.add(cb.value);
            });
            if (window.applyFilters) window.applyFilters();
        }
        
        function selectNoneTypes() {
            selectedTypes.clear();
            document.querySelectorAll('#type-filters input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            if (window.applyFilters) window.applyFilters();
        }
        
        function centerView() {
            if (window.Graph) {
                // Calculate bounding box of all visible nodes
                const nodes = window.Graph.graphData().nodes;
                if (nodes.length === 0) return;
                
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                let minZ = Infinity, maxZ = -Infinity;
                
                nodes.forEach(node => {
                    if (node.x !== undefined) {
                        minX = Math.min(minX, node.x);
                        maxX = Math.max(maxX, node.x);
                        minY = Math.min(minY, node.y);
                        maxY = Math.max(maxY, node.y);
                        minZ = Math.min(minZ, node.z);
                        maxZ = Math.max(maxZ, node.z);
                    }
                });
                
                // Calculate center and distance
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                const centerZ = (minZ + maxZ) / 2;
                
                const maxDist = Math.max(
                    maxX - minX,
                    maxY - minY,
                    maxZ - minZ
                );
                
                // Position camera to see all nodes
                const distance = maxDist * 1.5;
                window.Graph.cameraPosition(
                    { x: centerX, y: centerY, z: centerZ + distance },
                    { x: centerX, y: centerY, z: centerZ },
                    1000
                );
            }
        }
        
        // Wrap main code in IIFE
        (function() {
            console.log('Initializing AI Competitive Monitor 3D Force Graph...');
            
            let Graph;
            let graphData = { nodes: [], links: [] };
            let filteredData = { nodes: [], links: [] };
            let rawData = null;
            let linksEnabled = true;
            let labelsEnabled = true;
            let particlesEnabled = true;
            let thinLinesEnabled = false;
            let currentViewMode = 'entity-type';
            
            // Make applyFilters and Graph global for button access
            window.applyFilters = null;
            window.Graph = null;
            
            // Configuration
            const CONFIG = {
                linkDistance: 30,
                linkOpacity: 0.5,
                forceStrength: -300,
                fontWeight: 200,
                nodeColors: {
                    'AI Coding': '#ffeb3b',
                    'AI Hardware': '#4caf50',
                    'AI Infrastructure': '#9c27b0',
                    'AI Search': '#f44336',
                    'AI Voice/Audio': '#ff9800',
                    'Enterprise AI': '#d32f2f',
                    'Image Generation': '#e91e63',
                    'LLM Providers': '#ff5722',
                    'Video AI': '#3f51b5',
                    'AI Company': '#00ff88',
                    'AI Tool': '#ff6f00',
                    'AI Model Provider': '#ff00ff',
                    'AI Concept': '#00ffff',
                    'AI Assistant': '#ffff00',
                    'AI Platform': '#ff69b4',
                    'Company': '#6fbf6f',
                    'default': '#888888'
                },
                interestColors: {
                    10: '#ff0000',
                    9: '#ff3300',
                    8: '#ff6600',
                    7: '#ff9900',
                    6: '#ffcc00',
                    5: '#ffff00',
                    4: '#ccff00',
                    3: '#99ff00',
                    2: '#66ff00',
                    1: '#33ff00',
                    0: '#00ff00'
                },
                activityColors: {
                    high: '#ff0000',
                    medium: '#ffff00',
                    low: '#00ff00'
                },
                connectionColors: {
                    high: '#ff0000',
                    medium: '#ffff00',
                    low: '#00ff00'
                }
            };
            
            // Create text label for nodes
            function createNodeObject(node) {
                const sprite = new SpriteText(node.name);
                sprite.material.depthWrite = false;
                sprite.color = node.currentColor || node.color || CONFIG.nodeColors[node.group] || CONFIG.nodeColors.default;
                sprite.textHeight = 8;
                sprite.fontWeight = CONFIG.fontWeight;
                sprite.backgroundColor = false;
                return sprite;
            }
            
            // Calculate link width based on connection strength
            function getLinkWidth(link) {
                // If thin lines mode is enabled, return minimal width
                if (thinLinesEnabled) {
                    return 0.1;
                }
                
                // Start with very thin base width
                let width = 0.1;
                
                // Calculate strength based on shared properties
                let strength = 0;
                
                // Only make concept links thick - these are the most important
                if (link.label && link.label === 'uses concept') {
                    strength += 12;  // Much thicker for better visual impact
                }
                // Make technology links only slightly thicker if they have many connections
                else if (link.label && link.connectionCount && link.connectionCount > 3) {
                    strength += 1;  // Just barely visible increase
                }
                
                // Only add thickness for very high connection counts
                if (link.connectionCount && link.connectionCount > 5) {
                    strength += 1;
                }
                
                // Calculate final width - more dramatic range
                if (strength > 0) {
                    width = 0.1 + (strength * 0.2);
                }
                
                // Cap at reasonable maximum but allow thicker lines
                return Math.min(width, 2.5);
            }
            
            // Load and process data
            async function loadData() {
                try {
                    console.log('Loading data...');
                    
                    const [companiesResponse, detailsResponse] = await Promise.all([
                        fetch('https://redmorestudio.github.io/ai-competitive-monitor/api-data/companies.json'),
                        fetch('https://redmorestudio.github.io/ai-competitive-monitor/api-data/company-details.json')
                    ]);
                    
                    if (!companiesResponse.ok || !detailsResponse.ok) {
                        throw new Error('Failed to load data files');
                    }
                    
                    const companiesData = await companiesResponse.json();
                    const detailsData = await detailsResponse.json();
                    
                    rawData = {
                        dashboard: {
                            company_activity: []
                        }
                    };
                    
                    companiesData.companies.forEach(company => {
                        const companyName = company.company;
                        const details = Object.values(detailsData.companies).find(d => d.company_name === companyName);
                        
                        const companyEntry = {
                            company: companyName,
                            type: company.type,
                            entity_type: company.type,
                            url_count: company.urls.length,
                            intelligence: {
                                interest_level: details?.interest_level || 5,
                                ai_technologies: [],
                                ai_ml_concepts: []
                            }
                        };
                        
                        if (details?.products) {
                            details.products.forEach(product => {
                                if (product.uses_technologies) {
                                    // Normalize technology names to avoid duplicates
                                    const normalizedTechs = product.uses_technologies.map(tech => {
                                        // Convert to lowercase and trim
                                        const normalized = tech.trim().toLowerCase();
                                        // Capitalize first letter of each word
                                        return normalized.split(' ').map(word => 
                                            word.charAt(0).toUpperCase() + word.slice(1)
                                        ).join(' ');
                                    });
                                    companyEntry.intelligence.ai_technologies.push(...normalizedTechs);
                                }
                                if (product.ai_capabilities) {
                                    // Normalize concept names to avoid duplicates
                                    const normalizedConcepts = product.ai_capabilities.map(concept => {
                                        // Convert to lowercase and trim
                                        const normalized = concept.trim().toLowerCase();
                                        // Capitalize first letter of each word
                                        return normalized.split(' ').map(word => 
                                            word.charAt(0).toUpperCase() + word.slice(1)
                                        ).join(' ');
                                    });
                                    companyEntry.intelligence.ai_ml_concepts.push(...normalizedConcepts);
                                }
                            });
                            
                            companyEntry.intelligence.ai_technologies = [...new Set(companyEntry.intelligence.ai_technologies)];
                            companyEntry.intelligence.ai_ml_concepts = [...new Set(companyEntry.intelligence.ai_ml_concepts)];
                        }
                        
                        rawData.dashboard.company_activity.push(companyEntry);
                    });
                    
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('info').style.display = 'block';
                    document.getElementById('stats').style.display = 'block';
                    document.getElementById('legend').style.display = 'block';
                    document.getElementById('controls').style.display = 'block';
                    
                    buildGraph();
                    populateTypeFilters();
                    
                } catch (error) {
                    console.error('Error loading data:', error);
                    document.getElementById('loading').textContent = 'Error loading data: ' + error.message;
                }
            }
            
            function buildGraph() {
                console.log('Building graph...');
                
                graphData.nodes = [];
                graphData.links = [];
                
                const nodeMap = new Map();
                let totalUrls = 0;
                
                // Track connections per node
                const connectionCounts = new Map();
                
                rawData.dashboard.company_activity.forEach(company => {
                    const nodeType = company.entity_type || company.type || 'Company';
                    const node = {
                        id: company.company,
                        name: company.company,
                        group: nodeType,
                        color: CONFIG.nodeColors[nodeType] || CONFIG.nodeColors.default,
                        val: company.url_count || 1,
                        interestLevel: company.intelligence?.interest_level || 0,
                        urlCount: company.url_count || 0,
                        connectionCount: 0
                    };
                    graphData.nodes.push(node);
                    nodeMap.set(company.company, node);
                    totalUrls += company.url_count || 0;
                    connectionCounts.set(company.company, 0);
                });
                
                // Create technology links
                const techMap = new Map();
                const linkMap = new Map(); // Track link counts between nodes
                
                rawData.dashboard.company_activity.forEach(company => {
                    if (company.intelligence?.ai_technologies) {
                        company.intelligence.ai_technologies.forEach(tech => {
                            if (!techMap.has(tech)) {
                                techMap.set(tech, []);
                            }
                            techMap.get(tech).push(company.company);
                        });
                    }
                });
                
                // Connect companies that share technologies
                techMap.forEach((companies, tech) => {
                    if (companies.length > 1) {
                        for (let i = 0; i < companies.length - 1; i++) {
                            for (let j = i + 1; j < companies.length; j++) {
                                const key = [companies[i], companies[j]].sort().join('|');
                                
                                if (!linkMap.has(key)) {
                                    linkMap.set(key, {
                                        source: companies[i],
                                        target: companies[j],
                                        labels: [],
                                        count: 0
                                    });
                                }
                                
                                linkMap.get(key).labels.push(tech);
                                linkMap.get(key).count++;
                                
                                // Update connection counts
                                connectionCounts.set(companies[i], connectionCounts.get(companies[i]) + 1);
                                connectionCounts.set(companies[j], connectionCounts.get(companies[j]) + 1);
                            }
                        }
                    }
                });
                
                // Create concept nodes and links
                const conceptMap = new Map();
                rawData.dashboard.company_activity.forEach(company => {
                    if (company.intelligence?.ai_ml_concepts) {
                        company.intelligence.ai_ml_concepts.forEach(concept => {
                            if (!conceptMap.has(concept)) {
                                conceptMap.set(concept, []);
                            }
                            conceptMap.get(concept).push(company.company);
                        });
                    }
                });
                
                conceptMap.forEach((companies, concept) => {
                    if (companies.length >= 3) {
                        const conceptNode = {
                            id: `concept-${concept}`,
                            name: concept,
                            group: 'AI Concept',
                            color: CONFIG.nodeColors['AI Concept'],
                            val: companies.length * 4,
                            interestLevel: 5,
                            urlCount: 0,
                            connectionCount: companies.length
                        };
                        graphData.nodes.push(conceptNode);
                        
                        companies.forEach(company => {
                            graphData.links.push({
                                source: company,
                                target: conceptNode.id,
                                label: 'uses concept',
                                connectionCount: companies.length
                            });
                            
                            connectionCounts.set(company, connectionCounts.get(company) + 1);
                        });
                    }
                });
                
                // Convert linkMap to links array
                linkMap.forEach((linkData, key) => {
                    graphData.links.push({
                        source: linkData.source,
                        target: linkData.target,
                        label: linkData.labels[0], // Use first label
                        connectionCount: linkData.count
                    });
                });
                
                // Update node connection counts
                graphData.nodes.forEach(node => {
                    if (connectionCounts.has(node.id)) {
                        node.connectionCount = connectionCounts.get(node.id);
                    }
                });
                
                // Update stats
                document.getElementById('company-count').textContent = rawData.dashboard.company_activity.length;
                document.getElementById('url-count').textContent = totalUrls;
                document.getElementById('node-count').textContent = graphData.nodes.length;
                document.getElementById('link-count').textContent = graphData.links.length;
                
                // Initialize graph only once
                initializeGraph();
                
                // Apply initial filters
                applyFilters();
                updateLegend();
            }
            
            function populateTypeFilters() {
                const typeStats = new Map();
                graphData.nodes.forEach(node => {
                    if (!typeStats.has(node.group)) {
                        typeStats.set(node.group, 0);
                    }
                    typeStats.set(node.group, typeStats.get(node.group) + 1);
                });
                
                const container = document.getElementById('type-filters');
                container.innerHTML = '';
                
                Array.from(typeStats.entries())
                    .sort((a, b) => b[1] - a[1])
                    .forEach(([type, count]) => {
                        selectedTypes.add(type); // Initially all selected
                        
                        const item = document.createElement('div');
                        item.className = 'checkbox-item';
                        item.innerHTML = `
                            <input type="checkbox" id="type-${type.replace(/\s+/g, '-')}" value="${type}" checked>
                            <label for="type-${type.replace(/\s+/g, '-')}">
                                <span>${type}</span>
                                <span class="checkbox-count">(${count})</span>
                            </label>
                        `;
                        
                        item.querySelector('input').addEventListener('change', (e) => {
                            if (e.target.checked) {
                                selectedTypes.add(type);
                            } else {
                                selectedTypes.delete(type);
                            }
                            applyFilters();
                        });
                        
                        container.appendChild(item);
                    });
            }
            
            function applyFilters() {
                const searchTerm = document.getElementById('search-input')?.value.toLowerCase() || '';
                
                console.log('Applying filters. Selected types:', Array.from(selectedTypes));
                console.log('Total nodes before filter:', graphData.nodes.length);
                
                // Filter nodes
                filteredData.nodes = graphData.nodes.filter(node => {
                    // Type filter - if types are selected, only show matching types
                    if (selectedTypes.size > 0 && !selectedTypes.has(node.group)) {
                        return false;
                    }
                    // If no types selected via "Select None", show nothing
                    if (selectedTypes.size === 0 && document.querySelectorAll('#type-filters input[type="checkbox"]').length > 0) {
                        return false;
                    }
                    
                    // Search filter
                    if (searchTerm && !node.name.toLowerCase().includes(searchTerm)) {
                        return false;
                    }
                    
                    return true;
                });
                
                console.log('Nodes after filter:', filteredData.nodes.length);
                
                // Get filtered node IDs
                const filteredNodeIds = new Set(filteredData.nodes.map(n => n.id));
                
                // Filter links
                filteredData.links = graphData.links.filter(link => {
                    return filteredNodeIds.has(link.source.id || link.source) && 
                           filteredNodeIds.has(link.target.id || link.target);
                });
                
                // Apply view mode colors
                filteredData.nodes = filteredData.nodes.map(node => {
                    const newNode = {...node};
                    
                    if (currentViewMode === 'interest') {
                        newNode.currentColor = CONFIG.interestColors[node.interestLevel] || CONFIG.interestColors[5];
                    } else if (currentViewMode === 'activity') {
                        if (node.urlCount >= 10) {
                            newNode.currentColor = CONFIG.activityColors.high;
                        } else if (node.urlCount >= 5) {
                            newNode.currentColor = CONFIG.activityColors.medium;
                        } else {
                            newNode.currentColor = CONFIG.activityColors.low;
                        }
                    } else if (currentViewMode === 'connections') {
                        if (node.connectionCount >= 10) {
                            newNode.currentColor = CONFIG.connectionColors.high;
                        } else if (node.connectionCount >= 5) {
                            newNode.currentColor = CONFIG.connectionColors.medium;
                        } else {
                            newNode.currentColor = CONFIG.connectionColors.low;
                        }
                    } else {
                        // Entity type view
                        newNode.currentColor = node.color;
                    }
                    
                    return newNode;
                });
                
                // Update graph
                if (Graph) {
                    console.log('Updating graph with filtered data:', filteredData.nodes.length, 'nodes,', filteredData.links.length, 'links');
                    
                    // Need to create completely fresh objects to avoid reference issues
                    const freshData = {
                        nodes: filteredData.nodes.map(n => ({ ...n })),
                        links: filteredData.links.map(l => ({ 
                            source: l.source.id || l.source,
                            target: l.target.id || l.target,
                            label: l.label,
                            connectionCount: l.connectionCount,
                            ...l 
                        }))
                    };
                    
                    Graph.graphData(freshData);
                    
                    // Re-apply link width function after data update
                    Graph.linkWidth(link => getLinkWidth(link));
                }
                
                updateLegend();
            }
            
            // Make applyFilters available globally
            window.applyFilters = applyFilters;
            window.focusOnNode = null; // Will be set later
            
            // Focus on a specific node and its connections
            function focusOnNode(targetNode) {
                if (!targetNode) return;
                
                // Get all connected nodes
                const connectedNodeIds = new Set([targetNode.id]);
                
                // Find all links connected to this node
                graphData.links.forEach(link => {
                    const sourceId = link.source.id || link.source;
                    const targetId = link.target.id || link.target;
                    
                    if (sourceId === targetNode.id) {
                        connectedNodeIds.add(targetId);
                    }
                    if (targetId === targetNode.id) {
                        connectedNodeIds.add(sourceId);
                    }
                });
                
                // Filter to show only connected nodes
                filteredData.nodes = graphData.nodes.filter(node => 
                    connectedNodeIds.has(node.id)
                );
                
                // Filter links to only show connections between visible nodes
                filteredData.links = graphData.links.filter(link => {
                    const sourceId = link.source.id || link.source;
                    const targetId = link.target.id || link.target;
                    return connectedNodeIds.has(sourceId) && connectedNodeIds.has(targetId);
                });
                
                // Apply view mode colors
                filteredData.nodes = filteredData.nodes.map(node => {
                    const newNode = {...node};
                    
                    if (currentViewMode === 'interest') {
                        newNode.currentColor = CONFIG.interestColors[node.interestLevel] || CONFIG.interestColors[5];
                    } else if (currentViewMode === 'activity') {
                        if (node.urlCount >= 10) {
                            newNode.currentColor = CONFIG.activityColors.high;
                        } else if (node.urlCount >= 5) {
                            newNode.currentColor = CONFIG.activityColors.medium;
                        } else {
                            newNode.currentColor = CONFIG.activityColors.low;
                        }
                    } else if (currentViewMode === 'connections') {
                        if (node.connectionCount >= 10) {
                            newNode.currentColor = CONFIG.connectionColors.high;
                        } else if (node.connectionCount >= 5) {
                            newNode.currentColor = CONFIG.connectionColors.medium;
                        } else {
                            newNode.currentColor = CONFIG.connectionColors.low;
                        }
                    } else {
                        // Entity type view
                        newNode.currentColor = node.color;
                    }
                    
                    // Highlight the focused node
                    if (node.id === targetNode.id) {
                        newNode.currentColor = '#00ff88'; // Bright green for focused node
                    }
                    
                    return newNode;
                });
                
                // Update graph
                if (Graph) {
                    const freshData = {
                        nodes: filteredData.nodes.map(n => ({ ...n })),
                        links: filteredData.links.map(l => ({ 
                            source: l.source.id || l.source,
                            target: l.target.id || l.target,
                            label: l.label,
                            connectionCount: l.connectionCount,
                            ...l 
                        }))
                    };
                    
                    Graph.graphData(freshData);
                    Graph.linkWidth(link => getLinkWidth(link));
                    
                    // Center camera on the focused node
                    setTimeout(() => {
                        const distance = 300;
                        const distRatio = 1 + distance/Math.hypot(targetNode.x, targetNode.y, targetNode.z);
                        Graph.cameraPosition(
                            { x: targetNode.x * distRatio, y: targetNode.y * distRatio, z: targetNode.z * distRatio },
                            targetNode,
                            1000
                        );
                    }, 100);
                }
                
                // Update legend
                updateLegend();
                
                // Update info panel
                document.getElementById('node-info').innerHTML = 
                    `<strong>Focused on: ${targetNode.name}</strong><br>
                    Type: ${targetNode.group}<br>
                    Connected nodes: ${connectedNodeIds.size - 1}<br>
                    <em>Click "Select All" in filters to show all nodes again</em>`;
            }
            
            // Make focusOnNode globally available
            window.focusOnNode = focusOnNode;
            
            function updateLegend() {
                const nodeTypes = new Map();
                // If no filters selected or no filtered nodes, use all graph data
                const dataToUse = (selectedTypes.size === 0 || filteredData.nodes.length === 0) ? graphData : filteredData;
                
                dataToUse.nodes.forEach(node => {
                    const type = node.group;
                    if (!nodeTypes.has(type)) {
                        nodeTypes.set(type, {
                            color: currentViewMode === 'entity-type' ? 
                                (CONFIG.nodeColors[type] || CONFIG.nodeColors.default) : 
                                node.currentColor,
                            count: 0
                        });
                    }
                    nodeTypes.get(type).count++;
                });
                
                const legendContent = document.getElementById('legend-content');
                legendContent.innerHTML = '';
                
                const sortedTypes = Array.from(nodeTypes.entries())
                    .filter(([type, data]) => data.count > 0)
                    .sort((a, b) => b[1].count - a[1].count)
                    .slice(0, 10);
                
                sortedTypes.forEach(([type, data]) => {
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    item.innerHTML = `
                        <div class="legend-color" style="background-color: ${data.color}"></div>
                        <span>${type} (${data.count})</span>
                    `;
                    legendContent.appendChild(item);
                });
            }
            
            function initializeGraph() {
                console.log('Initializing 3D graph...');
                
                try {
                    // Only create new instance if it doesn't exist
                    if (!Graph) {
                        Graph = ForceGraph3D()(document.getElementById('3d-graph'));
                        window.Graph = Graph; // Make it globally accessible
                    }
                    
                    // Use full graph data for initial setup
                    const initialData = {
                        nodes: graphData.nodes.map(n => ({...n})),
                        links: graphData.links.map(l => ({...l}))
                    };
                    
                    Graph
                        .graphData(initialData)
                        .nodeLabel(node => `${node.name}\n${node.group}\nInterest: ${node.interestLevel}/10\nURLs: ${node.urlCount}\nConnections: ${node.connectionCount}`)
                        .nodeAutoColorBy('group')
                        .nodeVal('val')
                        .nodeThreeObject(node => {
                            if (!labelsEnabled) return new THREE.Mesh();
                            return createNodeObject(node);
                        })
                        .nodeThreeObjectExtend(false)
                        .linkWidth(link => getLinkWidth(link))
                        .linkColor(() => 'rgba(150, 150, 150, 0.5)')
                        .linkOpacity(CONFIG.linkOpacity)
                        .linkDirectionalParticles(2)
                        .linkDirectionalParticleSpeed(0.006)
                        .linkDirectionalParticleColor(() => '#00ff88')
                        .onNodeHover(node => {
                            document.getElementById('node-info').innerHTML = node ? 
                                `<strong>${node.name}</strong><br>Type: ${node.group}<br>Interest Level: ${node.interestLevel}/10<br>URLs: ${node.urlCount}<br>Connections: ${node.connectionCount}` : 
                                '<strong>Controls:</strong><br>â€¢ Left-click + drag = Rotate view<br>â€¢ Right-click + drag = Pan view<br>â€¢ Scroll = Zoom in/out<br>â€¢ Click node = Center camera<br>â€¢ Right-click node = Show context menu';
                        })
                        .onNodeClick(node => {
                            const distance = 300;
                            const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);
                            Graph.cameraPosition(
                                { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio },
                                node,
                                3000
                            );
                        })
                        .onNodeRightClick((node, event) => {
                            // Show context menu
                            event.preventDefault();
                            const menu = document.getElementById('context-menu');
                            const title = document.getElementById('context-menu-title');
                            
                            contextMenuNode = node;
                            title.textContent = node.name;
                            
                            // Position menu at cursor
                            menu.style.left = event.clientX + 'px';
                            menu.style.top = event.clientY + 'px';
                            menu.style.display = 'block';
                            
                            // Prevent menu from going off screen
                            const rect = menu.getBoundingClientRect();
                            if (rect.right > window.innerWidth) {
                                menu.style.left = (event.clientX - rect.width) + 'px';
                            }
                            if (rect.bottom > window.innerHeight) {
                                menu.style.top = (event.clientY - rect.height) + 'px';
                            }
                            
                            return false; // Prevent default browser context menu
                        })
                        .enablePointerInteraction(true)
                        .enableNodeDrag(true);
                    
                    Graph.d3Force('charge').strength(CONFIG.forceStrength);
                    Graph.d3Force('link').distance(CONFIG.linkDistance);
                    
                    Graph.cameraPosition({ x: 0, y: 0, z: 500 });
                    
                    console.log('Graph initialized successfully!');
                    
                } catch (error) {
                    console.error('Error initializing graph:', error);
                    document.getElementById('node-info').textContent = 'Error: ' + error.message;
                }
            }
            
            // Event handlers
            document.getElementById('toggle-links').addEventListener('change', (e) => {
                linksEnabled = e.target.checked;
                if (Graph) {
                    Graph.linkOpacity(linksEnabled ? CONFIG.linkOpacity : 0);
                }
            });
            
            document.getElementById('toggle-labels').addEventListener('change', (e) => {
                labelsEnabled = e.target.checked;
                if (Graph) {
                    Graph.nodeThreeObject(node => {
                        if (!labelsEnabled) return new THREE.Mesh();
                        return createNodeObject(node);
                    });
                }
            });
            
            document.getElementById('toggle-particles').addEventListener('change', (e) => {
                particlesEnabled = e.target.checked;
                if (Graph) {
                    Graph.linkDirectionalParticles(particlesEnabled ? 2 : 0);
                }
            });
            
            document.getElementById('toggle-thin-lines').addEventListener('change', (e) => {
                thinLinesEnabled = e.target.checked;
                if (Graph) {
                    // Re-apply link width function
                    Graph.linkWidth(link => getLinkWidth(link));
                }
            });
            
            document.getElementById('force-strength').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                document.getElementById('force-value').textContent = value;
                CONFIG.forceStrength = value;
                if (Graph) {
                    Graph.d3Force('charge').strength(value);
                    Graph.d3ReheatSimulation();
                }
            });
            
            document.getElementById('link-distance').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                document.getElementById('distance-value').textContent = value;
                CONFIG.linkDistance = value;
                if (Graph) {
                    Graph.d3Force('link').distance(value);
                    Graph.d3ReheatSimulation();
                }
            });
            
            document.getElementById('view-mode').addEventListener('change', (e) => {
                currentViewMode = e.target.value;
                applyFilters();
            });
            
            document.getElementById('search-input').addEventListener('input', (e) => {
                applyFilters();
            });
            
            // Toggle controls on mobile
            document.getElementById('toggle-controls').addEventListener('click', () => {
                document.getElementById('controls').classList.toggle('open');
            });
            
            // Start loading
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', loadData);
            } else {
                loadData();
            }
        })();
    </script>
</body>
</html>