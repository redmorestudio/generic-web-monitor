<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Competitive Monitor - 3D Force Graph</title>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0f;
            color: #eee;
            overflow: hidden;
        }
        
        /* Mobile controls styling */
        #toggle-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(20, 20, 30, 0.95);
            padding: 12px 16px;
            border-radius: 25px;
            border: 1px solid #333;
            cursor: pointer;
            z-index: 101;
            color: #00ff88;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        
        @media (max-width: 768px) {
            #toggle-controls {
                display: block;
            }
            
            #controls {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                transform: translateY(100%);
                transition: transform 0.3s ease;
                border-radius: 20px 20px 0 0;
                max-height: 60vh;
                width: auto;
                margin: 0;
            }
            
            #controls.open {
                transform: translateY(0);
            }
            
            #legend {
                display: none !important;
            }
            
            #info {
                font-size: 12px;
                padding: 10px;
                max-width: 250px;
            }
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(20, 20, 30, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            max-width: 350px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        #stats {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(20, 20, 30, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #333;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(20, 20, 30, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            z-index: 100;
            width: 280px;
            backdrop-filter: blur(10px);
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        
        .control-group:last-child {
            border-bottom: none;
        }
        
        label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            color: #aaa;
            font-size: 12px;
        }
        
        h3 {
            margin: 0 0 10px 0;
            color: #00ff88;
        }
        
        h4 {
            margin: 0 0 10px 0;
            color: #00ff88;
            font-size: 14px;
        }
        
        .green { color: #00ff88; }
        .stat-item { margin: 5px 0; }
        
        #legend {
            position: absolute;
            top: 10px;
            right: 310px;
            background: rgba(20, 20, 30, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            backdrop-filter: blur(10px);
            max-width: 200px;
            font-size: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        @media (max-width: 1200px) {
            #legend {
                display: none;
            }
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff88;
            font-size: 18px;
            z-index: 1000;
        }
        
        .slider-value {
            font-weight: bold;
            color: #00ff88;
            min-width: 45px;
            text-align: right;
        }
        
        select {
            background: rgba(0, 0, 0, 0.5);
            color: #eee;
            border: 1px solid #333;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        input[type="text"] {
            background: rgba(0, 0, 0, 0.5);
            color: #eee;
            border: 1px solid #333;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            width: 100%;
            margin-top: 5px;
        }
        
        .info-text {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
            font-style: italic;
        }
    </style>
    <script src="https://unpkg.com/three@0.152.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three-spritetext@1.8.0/dist/three-spritetext.min.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.0/dist/3d-force-graph.min.js"></script>
</head>
<body>
    <div id="loading">Loading AI Competitive Intelligence Graph...</div>
    
    <div id="info" style="display: none;">
        <h3>ðŸ§  AI Competitive Monitor</h3>
        <div id="node-info">
            <strong>Controls:</strong><br>
            â€¢ Left-click + drag = Rotate view<br>
            â€¢ Right-click + drag = Pan view<br>
            â€¢ Scroll = Zoom in/out<br>
            â€¢ Click node = Center camera
        </div>
    </div>
    
    <div id="stats" style="display: none;">
        <div class="stat-item">Monitoring: <span id="company-count" class="green">--</span> companies</div>
        <div class="stat-item">URLs: <span id="url-count" class="green">--</span></div>
        <div class="stat-item">Nodes: <span id="node-count" class="green">--</span></div>
        <div class="stat-item">Links: <span id="link-count" class="green">--</span></div>
    </div>
    
    <div id="legend" style="display: none;">
        <h4>â–¼ Legend</h4>
        <div class="info-text">Node Types</div>
        <div id="legend-content"></div>
    </div>
    
    <div id="controls" style="display: none;">
        <h4>Controls</h4>
        
        <div class="control-group">
            <h4 style="font-size: 12px; margin-bottom: 8px;">View Mode</h4>
            <label>
                Interest Analysis
                <select id="view-mode">
                    <option value="interest">Interest Analysis</option>
                    <option value="entity-type">Entity Type</option>
                    <option value="activity">Activity Level</option>
                </select>
            </label>
            <div class="info-text">
                â€¢ Interest: Colors by strategic interest<br>
                â€¢ Entity Type: Colors by company type<br>
                â€¢ Activity: Colors by URL count
            </div>
        </div>
        
        <div class="control-group">
            <h4 style="font-size: 12px; margin-bottom: 8px;">Visual Settings</h4>
            <label>
                Show Links
                <input type="checkbox" id="toggle-links" checked>
            </label>
            <label>
                Show Labels
                <input type="checkbox" id="toggle-labels" checked>
            </label>
            <label>
                Show Particles
                <input type="checkbox" id="toggle-particles" checked>
            </label>
        </div>
        
        <div class="control-group">
            <h4 style="font-size: 12px; margin-bottom: 8px;">Graph Physics</h4>
            <label>
                Force Strength
                <input type="range" id="force-strength" min="-1000" max="-50" value="-300" step="50">
                <span class="slider-value" id="force-value">-300</span>
            </label>
            <label>
                Link Distance
                <input type="range" id="link-distance" min="10" max="200" value="30" step="10">
                <span class="slider-value" id="distance-value">30</span>
            </label>
        </div>
        
        <div class="control-group">
            <h4 style="font-size: 12px; margin-bottom: 8px;">Filter by Type</h4>
            <select id="type-filter">
                <option value="all">All Types</option>
            </select>
        </div>
        
        <div class="control-group">
            <h4 style="font-size: 12px; margin-bottom: 8px;">Search</h4>
            <input type="text" id="search-input" placeholder="Search companies...">
        </div>
    </div>
    
    <button id="toggle-controls">â˜° Controls</button>
    <div id="3d-graph"></div>

    <script>
        // Wrap everything in an IIFE to avoid scope issues
        (function() {
            console.log('Initializing AI Competitive Monitor 3D Force Graph...');
            
            let Graph;
            let graphData = { nodes: [], links: [] };
            let filteredData = { nodes: [], links: [] };
            let rawData = null;
            let linksEnabled = true;
            let labelsEnabled = true;
            let particlesEnabled = true;
            let currentViewMode = 'entity-type';
            let currentTypeFilter = 'all';
            
            // Configuration
            const CONFIG = {
                linkDistance: 30,
                linkOpacity: 0.5, // 50% transparent as requested
                forceStrength: -300,
                fontWeight: 200, // Very thin font as requested
                nodeColors: {
                    'AI Coding': '#ffeb3b',
                    'AI Hardware': '#4caf50',
                    'AI Infrastructure': '#9c27b0',
                    'AI Search': '#f44336', // Saturated red as in legend
                    'AI Voice/Audio': '#ff9800',
                    'Enterprise AI': '#d32f2f',
                    'Image Generation': '#e91e63',
                    'LLM Providers': '#ff5722',
                    'Video AI': '#3f51b5',
                    'AI Company': '#00ff88',
                    'AI Tool': '#ff6f00',
                    'AI Model Provider': '#ff00ff',
                    'AI Concept': '#00ffff',
                    'AI Assistant': '#ffff00',
                    'AI Platform': '#ff69b4',
                    'Company': '#6fbf6f',
                    'default': '#888888'
                },
                // Interest level colors
                interestColors: {
                    10: '#ff0000',  // Red - Highest interest
                    9: '#ff3300',
                    8: '#ff6600',
                    7: '#ff9900',
                    6: '#ffcc00',
                    5: '#ffff00',   // Yellow - Medium interest
                    4: '#ccff00',
                    3: '#99ff00',
                    2: '#66ff00',
                    1: '#33ff00',
                    0: '#00ff00'    // Green - Low interest
                },
                // Activity level colors
                activityColors: {
                    high: '#ff0000',    // Red - Many URLs
                    medium: '#ffff00',  // Yellow - Some URLs
                    low: '#00ff00'      // Green - Few URLs
                }
            };
            
            // Create simple text label for nodes
            function createNodeObject(node) {
                const sprite = new SpriteText(node.name);
                sprite.material.depthWrite = false;
                sprite.color = node.currentColor || node.color || CONFIG.nodeColors[node.group] || CONFIG.nodeColors.default;
                sprite.textHeight = 8;
                sprite.fontWeight = CONFIG.fontWeight; // Use thin font weight
                sprite.backgroundColor = false; // No background
                return sprite;
            }
            
            // Calculate link width based on relationship
            function getLinkWidth(link) {
                // Base width for all links
                let width = 0.3;
                
                // Thicker for concept links
                if (link.label && link.label.includes('concept')) {
                    width = 0.8;
                }
                // Medium for technology links
                else if (link.label && techTerms.some(term => link.label.toLowerCase().includes(term))) {
                    width = 0.5;
                }
                
                return width;
            }
            
            // Common tech terms for identifying technology links
            const techTerms = ['api', 'sdk', 'framework', 'model', 'platform', 'engine', 'tool'];
            
            // Load and process data
            async function loadData() {
                try {
                    console.log('Loading data...');
                    
                    // Load multiple data files
                    const [companiesResponse, detailsResponse] = await Promise.all([
                        fetch('https://redmorestudio.github.io/ai-competitive-monitor/api-data/companies.json'),
                        fetch('https://redmorestudio.github.io/ai-competitive-monitor/api-data/company-details.json')
                    ]);
                    
                    if (!companiesResponse.ok || !detailsResponse.ok) {
                        throw new Error('Failed to load data files');
                    }
                    
                    const companiesData = await companiesResponse.json();
                    const detailsData = await detailsResponse.json();
                    
                    console.log('Companies data:', companiesData);
                    console.log('Details data:', detailsData);
                    
                    // Transform data into expected format
                    rawData = {
                        dashboard: {
                            company_activity: []
                        }
                    };
                    
                    // Combine companies with their details
                    companiesData.companies.forEach(company => {
                        const companyName = company.company;
                        // Find matching details
                        const details = Object.values(detailsData.companies).find(d => d.company_name === companyName);
                        
                        const companyEntry = {
                            company: companyName,
                            type: company.type,
                            entity_type: company.type, // Use type as entity_type
                            url_count: company.urls.length,
                            intelligence: {
                                interest_level: details?.interest_level || 5,
                                ai_technologies: [],
                                ai_ml_concepts: []
                            }
                        };
                        
                        // Extract technologies and concepts from products
                        if (details?.products) {
                            details.products.forEach(product => {
                                if (product.uses_technologies) {
                                    companyEntry.intelligence.ai_technologies.push(...product.uses_technologies);
                                }
                                if (product.ai_capabilities) {
                                    companyEntry.intelligence.ai_ml_concepts.push(...product.ai_capabilities);
                                }
                            });
                            
                            // Remove duplicates
                            companyEntry.intelligence.ai_technologies = [...new Set(companyEntry.intelligence.ai_technologies)];
                            companyEntry.intelligence.ai_ml_concepts = [...new Set(companyEntry.intelligence.ai_ml_concepts)];
                        }
                        
                        rawData.dashboard.company_activity.push(companyEntry);
                    });
                    
                    console.log('Transformed data:', rawData);
                    console.log('Company count:', rawData.dashboard.company_activity.length);
                    
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('info').style.display = 'block';
                    document.getElementById('stats').style.display = 'block';
                    document.getElementById('legend').style.display = 'block';
                    document.getElementById('controls').style.display = 'block';
                    
                    buildGraph();
                    populateTypeFilter();
                    
                } catch (error) {
                    console.error('Error loading data:', error);
                    document.getElementById('loading').textContent = 'Error loading data: ' + error.message;
                }
            }
            
            function buildGraph() {
                console.log('Building graph...');
                
                // Clear existing data
                graphData.nodes = [];
                graphData.links = [];
                
                // Create nodes
                const nodeMap = new Map();
                let totalUrls = 0;
                
                rawData.dashboard.company_activity.forEach(company => {
                    // Use entity_type if available, otherwise fall back to type
                    const nodeType = company.entity_type || company.type || 'Company';
                    const node = {
                        id: company.company,
                        name: company.company,
                        group: nodeType,
                        color: CONFIG.nodeColors[nodeType] || CONFIG.nodeColors.default,
                        val: company.url_count || 1,
                        interestLevel: company.intelligence?.interest_level || 0,
                        urlCount: company.url_count || 0
                    };
                    graphData.nodes.push(node);
                    nodeMap.set(company.company, node);
                    totalUrls += company.url_count || 0;
                });
                
                console.log(`Created ${graphData.nodes.length} nodes`);
                
                // Create links based on shared technologies
                const techMap = new Map();
                rawData.dashboard.company_activity.forEach(company => {
                    if (company.intelligence?.ai_technologies) {
                        company.intelligence.ai_technologies.forEach(tech => {
                            if (!techMap.has(tech)) {
                                techMap.set(tech, []);
                            }
                            techMap.get(tech).push(company.company);
                        });
                    }
                });
                
                // Connect companies that share technologies
                techMap.forEach((companies, tech) => {
                    if (companies.length > 1) {
                        for (let i = 0; i < companies.length - 1; i++) {
                            for (let j = i + 1; j < companies.length; j++) {
                                graphData.links.push({
                                    source: companies[i],
                                    target: companies[j],
                                    label: tech
                                });
                            }
                        }
                    }
                });
                
                // Add AI concept nodes
                const conceptMap = new Map();
                rawData.dashboard.company_activity.forEach(company => {
                    if (company.intelligence?.ai_ml_concepts) {
                        company.intelligence.ai_ml_concepts.forEach(concept => {
                            if (!conceptMap.has(concept)) {
                                conceptMap.set(concept, []);
                            }
                            conceptMap.get(concept).push(company.company);
                        });
                    }
                });
                
                // Create concept nodes for concepts shared by 3+ companies
                conceptMap.forEach((companies, concept) => {
                    if (companies.length >= 3) {
                        const conceptNode = {
                            id: `concept-${concept}`,
                            name: concept,
                            group: 'AI Concept',
                            color: CONFIG.nodeColors['AI Concept'],
                            val: companies.length * 4,
                            interestLevel: 5,
                            urlCount: 0
                        };
                        graphData.nodes.push(conceptNode);
                        
                        companies.forEach(company => {
                            graphData.links.push({
                                source: company,
                                target: conceptNode.id,
                                label: 'uses concept'
                            });
                        });
                    }
                });
                
                console.log(`Created ${graphData.links.length} links`);
                
                // Update stats
                document.getElementById('company-count').textContent = rawData.dashboard.company_activity.length;
                document.getElementById('url-count').textContent = totalUrls;
                document.getElementById('node-count').textContent = graphData.nodes.length;
                document.getElementById('link-count').textContent = graphData.links.length;
                
                // Set initial filtered data
                applyFilters();
                
                // Initialize the graph
                initializeGraph();
                
                // Update legend
                updateLegend();
            }
            
            function populateTypeFilter() {
                const types = new Set();
                graphData.nodes.forEach(node => {
                    types.add(node.group);
                });
                
                const select = document.getElementById('type-filter');
                select.innerHTML = '<option value="all">All Types</option>';
                
                Array.from(types).sort().forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type;
                    select.appendChild(option);
                });
            }
            
            function applyFilters() {
                const searchTerm = document.getElementById('search-input')?.value.toLowerCase() || '';
                
                // Filter nodes
                filteredData.nodes = graphData.nodes.filter(node => {
                    // Type filter
                    if (currentTypeFilter !== 'all' && node.group !== currentTypeFilter) {
                        return false;
                    }
                    
                    // Search filter
                    if (searchTerm && !node.name.toLowerCase().includes(searchTerm)) {
                        return false;
                    }
                    
                    return true;
                });
                
                // Get filtered node IDs
                const filteredNodeIds = new Set(filteredData.nodes.map(n => n.id));
                
                // Filter links to only include those between filtered nodes
                filteredData.links = graphData.links.filter(link => {
                    return filteredNodeIds.has(link.source.id || link.source) && 
                           filteredNodeIds.has(link.target.id || link.target);
                });
                
                // Apply view mode colors
                filteredData.nodes = filteredData.nodes.map(node => {
                    const newNode = {...node};
                    
                    if (currentViewMode === 'interest') {
                        newNode.currentColor = CONFIG.interestColors[node.interestLevel] || CONFIG.interestColors[5];
                    } else if (currentViewMode === 'activity') {
                        if (node.urlCount >= 10) {
                            newNode.currentColor = CONFIG.activityColors.high;
                        } else if (node.urlCount >= 5) {
                            newNode.currentColor = CONFIG.activityColors.medium;
                        } else {
                            newNode.currentColor = CONFIG.activityColors.low;
                        }
                    } else {
                        // Entity type view - use original colors
                        newNode.currentColor = node.color;
                    }
                    
                    return newNode;
                });
                
                // Update graph with filtered data
                if (Graph) {
                    Graph.graphData({
                        nodes: filteredData.nodes.map(n => ({...n})),
                        links: filteredData.links.map(l => ({...l}))
                    });
                }
                
                // Update legend based on filtered data
                updateLegend();
            }
            
            function updateLegend() {
                const nodeTypes = new Map();
                const dataToUse = filteredData.nodes.length > 0 ? filteredData : graphData;
                
                dataToUse.nodes.forEach(node => {
                    const type = node.group;
                    if (!nodeTypes.has(type)) {
                        nodeTypes.set(type, {
                            color: node.currentColor || CONFIG.nodeColors[type] || CONFIG.nodeColors.default,
                            count: 0
                        });
                    }
                    nodeTypes.get(type).count++;
                });
                
                const legendContent = document.getElementById('legend-content');
                legendContent.innerHTML = '';
                
                // Sort by count and limit to types that exist
                const sortedTypes = Array.from(nodeTypes.entries())
                    .filter(([type, data]) => data.count > 0)
                    .sort((a, b) => b[1].count - a[1].count)
                    .slice(0, 10); // Show top 10 types
                
                sortedTypes.forEach(([type, data]) => {
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    item.innerHTML = `
                        <div class="legend-color" style="background-color: ${data.color}"></div>
                        <span>${type} (${data.count})</span>
                    `;
                    legendContent.appendChild(item);
                });
            }
            
            function initializeGraph() {
                console.log('Initializing 3D graph...');
                
                try {
                    // Create graph instance
                    Graph = ForceGraph3D()(document.getElementById('3d-graph'));
                    
                    // Set clean data
                    const cleanData = {
                        nodes: filteredData.nodes.map(n => ({...n})),
                        links: filteredData.links.map(l => ({...l}))
                    };
                    
                    Graph
                        .graphData(cleanData)
                        .nodeLabel(node => `${node.name}\n${node.group}\nInterest: ${node.interestLevel}/10\nURLs: ${node.urlCount}`)
                        .nodeAutoColorBy('group')
                        .nodeVal('val')
                        .nodeThreeObject(node => {
                            if (!labelsEnabled) return new THREE.Mesh();
                            return createNodeObject(node);
                        })
                        .nodeThreeObjectExtend(false)
                        .linkWidth(link => getLinkWidth(link))
                        .linkColor(() => 'rgba(150, 150, 150, 0.5)') // Light grey with 50% transparency
                        .linkOpacity(CONFIG.linkOpacity)
                        .linkDirectionalParticles(2)
                        .linkDirectionalParticleSpeed(0.006)
                        .linkDirectionalParticleColor(() => '#00ff88')
                        .onNodeHover(node => {
                            document.getElementById('node-info').innerHTML = node ? 
                                `<strong>${node.name}</strong><br>Type: ${node.group}<br>Interest Level: ${node.interestLevel}/10<br>URLs: ${node.urlCount}` : 
                                '<strong>Controls:</strong><br>â€¢ Left-click + drag = Rotate view<br>â€¢ Right-click + drag = Pan view<br>â€¢ Scroll = Zoom in/out<br>â€¢ Click node = Center camera';
                        })
                        .onNodeClick(node => {
                            // Center camera on node
                            const distance = 300;
                            const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);
                            Graph.cameraPosition(
                                { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio },
                                node,
                                3000
                            );
                        })
                        .enablePointerInteraction(true)
                        .enableNodeDrag(true);
                    
                    // Set basic forces
                    Graph.d3Force('charge').strength(CONFIG.forceStrength);
                    Graph.d3Force('link').distance(CONFIG.linkDistance);
                    
                    // Set initial camera position
                    Graph.cameraPosition({ x: 0, y: 0, z: 500 });
                    
                    console.log('Graph initialized successfully!');
                    
                } catch (error) {
                    console.error('Error initializing graph:', error);
                    console.error('Stack:', error.stack);
                    document.getElementById('node-info').textContent = 'Error: ' + error.message;
                }
            }
            
            // Event handlers
            document.getElementById('toggle-links').addEventListener('change', (e) => {
                linksEnabled = e.target.checked;
                if (Graph) {
                    Graph.linkOpacity(linksEnabled ? CONFIG.linkOpacity : 0);
                }
            });
            
            document.getElementById('toggle-labels').addEventListener('change', (e) => {
                labelsEnabled = e.target.checked;
                if (Graph) {
                    Graph.nodeThreeObject(node => {
                        if (!labelsEnabled) return new THREE.Mesh();
                        return createNodeObject(node);
                    });
                }
            });
            
            document.getElementById('toggle-particles').addEventListener('change', (e) => {
                particlesEnabled = e.target.checked;
                if (Graph) {
                    Graph.linkDirectionalParticles(particlesEnabled ? 2 : 0);
                }
            });
            
            document.getElementById('force-strength').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                document.getElementById('force-value').textContent = value;
                CONFIG.forceStrength = value;
                if (Graph) {
                    Graph.d3Force('charge').strength(value);
                    Graph.d3ReheatSimulation();
                }
            });
            
            document.getElementById('link-distance').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                document.getElementById('distance-value').textContent = value;
                CONFIG.linkDistance = value;
                if (Graph) {
                    Graph.d3Force('link').distance(value);
                    Graph.d3ReheatSimulation();
                }
            });
            
            document.getElementById('view-mode').addEventListener('change', (e) => {
                currentViewMode = e.target.value;
                applyFilters();
            });
            
            document.getElementById('type-filter').addEventListener('change', (e) => {
                currentTypeFilter = e.target.value;
                applyFilters();
            });
            
            document.getElementById('search-input').addEventListener('input', (e) => {
                applyFilters();
            });
            
            // Toggle controls on mobile
            document.getElementById('toggle-controls').addEventListener('click', () => {
                document.getElementById('controls').classList.toggle('open');
            });
            
            // Start loading data when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', loadData);
            } else {
                loadData();
            }
        })();
    </script>
</body>
</html>