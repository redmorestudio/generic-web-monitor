<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Competitive Monitor - 3D Force Graph</title>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0f;
            color: #eee;
            overflow: hidden;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(20, 20, 30, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            max-width: 350px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        #info h3 {
            margin: 0 0 10px 0;
            color: #00ff88;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(20, 20, 30, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            z-index: 100;
            width: 280px;
            backdrop-filter: blur(10px);
        }
        
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        
        .control-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 12px;
        }
        
        .label-value {
            color: #00ff88;
            font-weight: bold;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
            cursor: pointer;
        }
        
        select, button {
            width: 100%;
            padding: 8px;
            background: #1a1a2e;
            color: #eee;
            border: 1px solid #333;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        button {
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: #2a2a3e;
            border-color: #00ff88;
            transform: translateY(-1px);
        }
        
        button.active {
            background: #00ff88;
            color: #0a0a0f;
            font-weight: bold;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: #00ff88;
            text-align: center;
        }
        
        .loading-spinner {
            border: 3px solid rgba(0, 255, 136, 0.3);
            border-radius: 50%;
            border-top: 3px solid #00ff88;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #stats {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(20, 20, 30, 0.95);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #333;
            font-size: 12px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        #legend {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(20, 20, 30, 0.95);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #333;
            font-size: 11px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .help-text {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
            font-style: italic;
        }
        
        .toggle-group {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }
        
        .toggle-btn {
            flex: 1;
            padding: 5px;
            font-size: 11px;
        }
        
        /* Context menu styles */
        #contextMenu {
            position: absolute;
            background: rgba(20, 20, 30, 0.95);
            border: 1px solid #00ff88;
            border-radius: 8px;
            padding: 5px 0;
            display: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        
        .context-menu-item {
            padding: 8px 20px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        
        .context-menu-item:hover {
            background: rgba(0, 255, 136, 0.2);
        }
        
        /* Rich node content styles */
        .node-content {
            background: rgba(20, 20, 30, 0.95);
            border: 2px solid;
            border-radius: 8px;
            padding: 10px;
            font-size: 11px;
            max-width: 250px;
            backdrop-filter: blur(10px);
        }
        
        .node-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 13px;
        }
        
        .node-detail {
            margin: 3px 0;
            color: #aaa;
        }
        
        .entity-link {
            color: #00ff88;
            cursor: pointer;
            text-decoration: none;
            transition: color 0.2s;
        }
        
        .entity-link:hover {
            color: #66ffbb;
            text-decoration: underline;
        }
        
        .change-indicator {
            display: inline-block;
            margin-left: 5px;
            font-size: 10px;
        }
        
        /* Tooltip */
        .tooltip {
            position: absolute;
            background: rgba(20, 20, 30, 0.95);
            border: 1px solid #00ff88;
            border-radius: 8px;
            padding: 10px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            backdrop-filter: blur(10px);
            display: none;
        }
    </style>
    <script src="https://unpkg.com/three@0.152.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three-spritetext@1.8.0/dist/three-spritetext.min.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.0/dist/3d-force-graph.min.js"></script>
</head>
<body>
    <div id="loading">
        <div>Loading AI Competitive Intelligence Graph...</div>
        <div class="loading-spinner"></div>
    </div>
    
    <div id="info" style="display: none;">
        <h3>
            <span>ðŸ§ </span>
            AI Competitive Monitor
        </h3>
        <div id="node-info">Right-click on nodes to focus on subgraph</div>
    </div>
    
    <div id="controls" style="display: none;">
        <div class="control-group">
            <label>
                Force Strength:
                <span class="label-value" id="forceValue">-100</span>
            </label>
            <input type="range" id="forceSlider" min="-300" max="-30" value="-100" step="10">
            <div class="help-text">Adjust spacing between nodes</div>
        </div>
        
        <div class="control-group">
            <label>
                Link Distance:
                <span class="label-value" id="linkDistanceValue">30</span>
            </label>
            <input type="range" id="linkDistanceSlider" min="10" max="200" value="30" step="10">
            <div class="help-text">Control link lengths</div>
        </div>
        
        <div class="control-group">
            <label>
                Font Size:
                <span class="label-value" id="fontSizeValue">12</span>
            </label>
            <input type="range" id="fontSizeSlider" min="8" max="24" value="12" step="1">
            <div class="help-text">Adjust label text size</div>
        </div>
        
        <div class="control-group">
            <label>View Mode:</label>
            <select id="viewMode">
                <option value="companies">Company Network</option>
                <option value="technologies">Technology Landscape</option>
                <option value="concepts">AI/ML Concepts</option>
                <option value="partners">Partner Network</option>
                <option value="interests">Interest Analysis</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Filter by Type:</label>
            <select id="filterType">
                <option value="all">All Companies</option>
                <option value="LLM Providers">LLM Providers</option>
                <option value="AI Hardware">AI Hardware</option>
                <option value="AI Frameworks">AI Frameworks</option>
                <option value="Cloud Providers">Cloud Providers</option>
                <option value="none">No Companies (Concepts Only)</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Node Display:</label>
            <div class="toggle-group">
                <button id="nodeSimple" class="toggle-btn">Simple</button>
                <button id="nodeRich" class="toggle-btn active">Rich Content</button>
            </div>
            <div class="help-text">Toggle between simple labels and rich content boxes</div>
        </div>
        
        <div class="control-group">
            <label>Visual Effects:</label>
            <button id="toggleParticles">Toggle Flow Particles</button>
            <div class="help-text">Particles show data flow direction</div>
            <button id="toggleLabels" style="margin-top: 5px;">Toggle All Labels</button>
            <button id="toggleLinks" style="margin-top: 5px;">Toggle Links</button>
            <button id="toggleChangeRings" style="margin-top: 5px;">Toggle Change Indicators</button>
            <div class="help-text">Change rings show recent activity level</div>
        </div>
    </div>
    
    <div id="stats" style="display: none;">
        <div id="statsContent"></div>
    </div>
    
    <div id="legend" style="display: none;">
        <strong>Legend:</strong>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff6b6b;"></div>
            <span>LLM Providers</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #4ecdc4;"></div>
            <span>AI Hardware</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #45b7d1;"></div>
            <span>AI Frameworks</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #96ceb4;"></div>
            <span>Cloud Providers</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ff88;"></div>
            <span>AI Concepts</span>
        </div>
        <hr style="border-color: #333; margin: 8px 0;">
        <div class="legend-item">
            <div class="legend-color" style="background: #ff4444;"></div>
            <span>High Changes (8-10)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ffa726;"></div>
            <span>Medium Changes (5-7)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #66bb6a;"></div>
            <span>Low Changes (1-4)</span>
        </div>
    </div>
    
    <!-- Context Menu -->
    <div id="contextMenu">
        <div class="context-menu-item" id="focusSubgraph">Focus on Connected Subgraph</div>
        <div class="context-menu-item" id="showAllConnections">Show All Connections</div>
        <div class="context-menu-item" id="hideNode">Hide This Node</div>
        <div class="context-menu-item" id="resetView">Reset View</div>
    </div>
    
    <!-- Tooltip -->
    <div id="tooltip" class="tooltip"></div>
    
    <div id="3d-graph"></div>

    <script>
    // Enhanced Configuration
    const CONFIG = {
        nodeColors: {
            'LLM Providers': '#ff6b6b',
            'AI Hardware': '#4ecdc4',
            'AI Frameworks': '#45b7d1',
            'Cloud Providers': '#96ceb4',
            'AI Applications': '#f7b731',
            'AI Research': '#5f27cd',
            'default': '#667eea'
        },
        interestColors: {
            'high': '#ff4444',
            'medium': '#ffa726',
            'low': '#66bb6a',
            'unknown': '#666666'
        },
        particleSpeed: 0.003,
        linkOpacity: 0.3,
        linkWidth: 0.5,
        nodeRelSize: 4,
        forceStrength: -100,
        linkDistance: 30,
        fontSize: 12
    };

    let Graph;
    let graphData = { nodes: [], links: [] };
    let fullGraphData = { nodes: [], links: [] }; // Store full graph for resetting
    let rawData = {};
    let particlesEnabled = true;
    let labelsEnabled = true;
    let linksEnabled = true;
    let changeRingsEnabled = true;
    let autoRotateEnabled = false;
    let currentView = 'companies';
    let nodeDisplayMode = 'rich'; // Default to rich view
    let selectedNode = null;
    let hiddenNodes = new Set();

    // Initialize the enhanced graph
    async function initGraph() {
        try {
            console.log('Starting graph initialization...');
            
            // Determine base URL
            const isLocal = window.location.hostname === 'localhost' || 
                          window.location.hostname === '127.0.0.1' || 
                          window.location.hostname === '' ||
                          window.location.protocol === 'file:';
            
            const baseUrl = isLocal ? './api-data' : 'https://redmorestudio.github.io/ai-competitive-monitor/api-data';
            
            console.log('Loading from:', baseUrl);
            
            // Fetch data
            console.log('Fetching dashboard data...');
            const dashboardResponse = await fetch(`${baseUrl}/dashboard.json`);
            if (!dashboardResponse.ok) {
                throw new Error(`Failed to fetch dashboard: ${dashboardResponse.status} ${dashboardResponse.statusText}`);
            }
            
            console.log('Parsing dashboard data...');
            rawData.dashboard = await dashboardResponse.json();
            
            // Fetch recent changes data
            console.log('Fetching recent changes...');
            try {
                const changesResponse = await fetch(`${baseUrl}/changes.json`);
                if (changesResponse.ok) {
                    rawData.changes = await changesResponse.json();
                    console.log('Recent changes loaded:', rawData.changes.changes?.length || 0);
                }
            } catch (e) {
                console.log('Could not load changes data:', e);
            }
            
            console.log('Dashboard data loaded:', {
                hasData: !!rawData.dashboard,
                hasCompanyActivity: !!rawData.dashboard.company_activity,
                companyCount: rawData.dashboard.company_activity?.length || 0,
                stats: rawData.dashboard.stats
            });
            
            // Validate data structure
            if (!rawData.dashboard.company_activity || rawData.dashboard.company_activity.length === 0) {
                throw new Error('No company activity data found');
            }
            
            // Build initial graph data
            console.log('Building company network...');
            buildCompanyNetwork();
            
            // Hide loading, show controls
            document.getElementById('loading').style.display = 'none';
            document.getElementById('info').style.display = 'block';
            document.getElementById('controls').style.display = 'block';
            document.getElementById('stats').style.display = 'block';
            document.getElementById('legend').style.display = 'block';
            
            // Create the enhanced graph
            console.log('Creating 3D graph...');
            Graph = ForceGraph3D()
                (document.getElementById('3d-graph'))
                .graphData(graphData)
                .nodeLabel(node => '')
                .nodeAutoColorBy('group')
                .nodeRelSize(CONFIG.nodeRelSize)
                .nodeVal(node => node.val || 10)
                .nodeThreeObject(node => createNodeObject(node))
                .nodeThreeObjectExtend(false)
                .linkWidth(link => linksEnabled ? (link.width || CONFIG.linkWidth) : 0)
                .linkOpacity(linksEnabled ? CONFIG.linkOpacity : 0)
                .linkDirectionalParticles(link => particlesEnabled ? (link.particles || 2) : 0)
                .linkDirectionalParticleSpeed(CONFIG.particleSpeed)
                .linkDirectionalParticleWidth(2)
                .linkDirectionalParticleColor(link => link.color || '#ffffff')
                .linkLabel(link => link.label || '')
                .onNodeHover(handleNodeHover)
                .onNodeClick(handleNodeClick)
                .onNodeRightClick(handleNodeRightClick)
                .onBackgroundClick(() => {
                    document.getElementById('node-info').innerHTML = 'Right-click on nodes to focus on subgraph';
                    hideContextMenu();
                })
                .onBackgroundRightClick((event) => {
                    event.preventDefault();
                    hideContextMenu();
                });
            
            // Set forces
            Graph.d3Force('charge').strength(CONFIG.forceStrength);
            Graph.d3Force('link').distance(link => link.distance || CONFIG.linkDistance);
            
            // Set initial camera position
            Graph.cameraPosition({ x: 0, y: 0, z: 500 });
            
            updateStats();
            console.log('Graph initialized successfully!');
            
        } catch (error) {
            console.error('Error loading data:', error);
            document.getElementById('loading').innerHTML = `
                <div style="color: #ff6b6b; text-align: center;">
                    <h3>Error Loading Data</h3>
                    <p>${error.message}</p>
                    <p style="font-size: 14px; color: #aaa;">
                        Make sure you're running a local server:<br>
                        <code>python -m http.server 8000</code><br>
                        Then visit: http://localhost:8000/3d-force-graph-local.html
                    </p>
                </div>
            `;
        }
    }

    // Create node object based on display mode
    function createNodeObject(node) {
        if (nodeDisplayMode === 'rich') {
            return createRichNode(node);
        } else {
            return createSimpleNode(node);
        }
    }

    // Create simple text sprite node
    function createSimpleNode(node) {
        const group = new THREE.Group();
        
        // Create text sprite with better color contrast
        const sprite = new SpriteText(node.name);
        sprite.material.depthWrite = false;
        
        // Use yellow for blue-ish colors to improve contrast
        const blueishColors = ['#45b7d1', '#4ecdc4', '#66bb6a', '#667eea'];
        if (blueishColors.includes(node.color)) {
            sprite.color = '#ffeb3b'; // Yellow
        } else {
            sprite.color = '#ffffff'; // White for others
        }
        
        sprite.textHeight = CONFIG.fontSize;
        sprite.visible = labelsEnabled;
        group.add(sprite);
        
        // Add change indicator ring if enabled
        if (changeRingsEnabled && node.changeLevel > 0) {
            const ringGeometry = new THREE.RingGeometry(8, 10, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: getChangeColor(node.changeLevel),
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            group.add(ring);
        }
        
        return group;
    }

    // Create rich content node
    function createRichNode(node) {
        const group = new THREE.Group();
        
        // Create a sphere for the node
        const geometry = new THREE.SphereGeometry(5, 32, 32);
        const material = new THREE.MeshBasicMaterial({
            color: node.color,
            transparent: true,
            opacity: 0.8
        });
        const sphere = new THREE.Mesh(geometry, material);
        group.add(sphere);
        
        // Add text label with better color contrast
        const sprite = new SpriteText(node.name);
        sprite.material.depthWrite = false;
        
        // Use yellow for blue-ish colors to improve contrast
        const blueishColors = ['#45b7d1', '#4ecdc4', '#66bb6a', '#667eea'];
        if (blueishColors.includes(node.color)) {
            sprite.color = '#ffeb3b'; // Yellow
        } else {
            sprite.color = '#ffffff'; // White for others
        }
        
        sprite.textHeight = CONFIG.fontSize - 2;
        sprite.position.y = 10;
        sprite.visible = labelsEnabled;
        group.add(sprite);
        
        // Add change level indicator ring
        if (changeRingsEnabled && node.changeLevel > 0) {
            const ringGeometry = new THREE.RingGeometry(7, 9, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: getChangeColor(node.changeLevel),
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            
            // Animate the ring
            ring.userData.update = () => {
                ring.rotation.z += 0.01;
            };
            
            group.add(ring);
        }
        
        return group;
    }

    // Get color based on change level
    function getChangeColor(changeLevel) {
        if (changeLevel >= 8) return CONFIG.interestColors.high;
        if (changeLevel >= 5) return CONFIG.interestColors.medium;
        if (changeLevel >= 1) return CONFIG.interestColors.low;
        return CONFIG.interestColors.unknown;
    }

    // Calculate change level for a company based on recent changes
    function getCompanyChangeLevel(companyName) {
        if (!rawData.changes || !rawData.changes.changes) return 0;
        
        // Look for recent changes for this company
        const recentChanges = rawData.changes.changes.filter(change => 
            change.company === companyName && 
            change.interest_level !== undefined
        );
        
        if (recentChanges.length === 0) return 0;
        
        // Return the highest interest level from recent changes
        return Math.max(...recentChanges.map(c => c.interest_level || 0));
    }

    // Build company network view with enhanced data
    function buildCompanyNetwork() {
        try {
            console.log('Starting buildCompanyNetwork...');
            graphData.nodes = [];
            graphData.links = [];
            const nodeMap = new Map();
            
            // Create enhanced company nodes
            console.log('Creating company nodes...');
            rawData.dashboard.company_activity.forEach((company, index) => {
                const changeLevel = getCompanyChangeLevel(company.company);
                
                const node = {
                    id: company.company,
                    name: company.company,
                    group: company.type,
                    color: CONFIG.nodeColors[company.type] || CONFIG.nodeColors.default,
                    description: `URLs: ${company.url_count}<br/>Interest: ${company.intelligence?.interest_category || 'unknown'}`,
                    shortDescription: `${company.type} â€¢ ${company.url_count} URLs`,
                    val: company.url_count * 5,
                    interestLevel: company.intelligence?.interest_level || 0,
                    changeLevel: changeLevel,
                    entityCount: company.url_count,
                    // Rich data for display
                    products: company.intelligence?.products?.slice(0, 3) || [],
                    technologies: company.intelligence?.technologies?.slice(0, 3) || [],
                    concepts: company.intelligence?.ai_ml_concepts?.slice(0, 3) || [],
                    partners: company.intelligence?.partners?.slice(0, 2) || []
                };
                graphData.nodes.push(node);
                nodeMap.set(company.company, node);
            });
            
            console.log(`Created ${graphData.nodes.length} company nodes`);
            
            // Create technology connections
            const techConnections = new Map();
            
            rawData.dashboard.company_activity.forEach(company => {
                if (company.intelligence?.technologies) {
                    company.intelligence.technologies.forEach(tech => {
                        if (!techConnections.has(tech)) {
                            techConnections.set(tech, []);
                        }
                        techConnections.get(tech).push(company.company);
                    });
                }
            });
            
            // Create links between companies sharing technologies
            techConnections.forEach((companies, tech) => {
                if (companies.length > 1) {
                    for (let i = 0; i < companies.length - 1; i++) {
                        for (let j = i + 1; j < companies.length; j++) {
                            graphData.links.push({
                                source: companies[i],
                                target: companies[j],
                                label: tech,
                                color: '#666',
                                particles: 1,
                                width: 0.5,
                                distance: CONFIG.linkDistance
                            });
                        }
                    }
                }
            });
            
            // Add AI concept hub nodes for major concepts
            const conceptConnections = new Map();
            rawData.dashboard.company_activity.forEach(company => {
                if (company.intelligence?.ai_ml_concepts) {
                    company.intelligence.ai_ml_concepts.forEach(concept => {
                        if (!conceptConnections.has(concept)) {
                            conceptConnections.set(concept, []);
                        }
                        conceptConnections.get(concept).push(company.company);
                    });
                }
            });
            
            // Only create concept nodes for concepts shared by 3+ companies
            conceptConnections.forEach((companies, concept) => {
                if (companies.length >= 3) {
                    const conceptNode = {
                        id: `concept-${concept}`,
                        name: concept,
                        group: 'AI Concept',
                        color: '#00ff88',
                        val: companies.length * 4,
                        description: `Shared by ${companies.length} companies`,
                        shortDescription: `AI/ML Concept`,
                        companies: companies,
                        changeLevel: 0
                    };
                    graphData.nodes.push(conceptNode);
                    
                    companies.forEach(company => {
                        graphData.links.push({
                            source: company,
                            target: conceptNode.id,
                            color: '#00ff88',
                            particles: 2,
                            width: 1,
                            distance: CONFIG.linkDistance * 0.8
                        });
                    });
                }
            });
            
            // Store full graph data for resetting
            // Create a proper deep copy without circular references
            fullGraphData = {
                nodes: graphData.nodes.map(node => ({ ...node })),
                links: graphData.links.map(link => ({
                    ...link,
                    source: typeof link.source === 'object' ? link.source.id : link.source,
                    target: typeof link.target === 'object' ? link.target.id : link.target
                }))
            };
            
            console.log(`Graph built with ${graphData.nodes.length} nodes and ${graphData.links.length} links`);
            
        } catch (error) {
            console.error('Error in buildCompanyNetwork:', error);
            throw error;
        }
    }

    // Build technology view
    function buildTechnologyView() {
        graphData.nodes = [];
        graphData.links = [];
        
        const techNodes = new Map();
        
        rawData.dashboard.company_activity.forEach(company => {
            if (company.intelligence?.technologies) {
                company.intelligence.technologies.forEach(tech => {
                    if (!techNodes.has(tech)) {
                        techNodes.set(tech, {
                            id: `tech-${tech}`,
                            name: tech,
                            group: 'Technology',
                            color: '#4ecdc4',
                            companies: [],
                            val: 10,
                            shortDescription: 'Technology Stack',
                            changeLevel: 0
                        });
                    }
                    techNodes.get(tech).companies.push(company.company);
                    techNodes.get(tech).val += 5;
                });
            }
        });
        
        techNodes.forEach(node => {
            node.description = `Used by ${node.companies.length} companies`;
            graphData.nodes.push(node);
        });
        
        rawData.dashboard.company_activity.forEach(company => {
            const changeLevel = getCompanyChangeLevel(company.company);
            graphData.nodes.push({
                id: company.company,
                name: company.company,
                group: company.type,
                color: CONFIG.nodeColors[company.type] || CONFIG.nodeColors.default,
                val: 5,
                shortDescription: company.type,
                changeLevel: changeLevel
            });
        });
        
        techNodes.forEach((techNode, tech) => {
            techNode.companies.forEach(company => {
                graphData.links.push({
                    source: techNode.id,
                    target: company,
                    particles: 2,
                    color: '#4ecdc4'
                });
            });
        });
    }

    // Build interest analysis view
    function buildInterestView() {
        graphData.nodes = [];
        graphData.links = [];
        
        // Create interest level nodes
        const interestLevels = ['high', 'medium', 'low'];
        const interestNodes = {};
        
        interestLevels.forEach(level => {
            const node = {
                id: `interest-${level}`,
                name: `${level.toUpperCase()} INTEREST`,
                group: 'Interest Level',
                color: CONFIG.interestColors[level],
                val: 30,
                shortDescription: 'Interest Category',
                changeLevel: 0
            };
            graphData.nodes.push(node);
            interestNodes[level] = node;
        });
        
        // Add companies connected to their interest levels
        rawData.dashboard.company_activity.forEach(company => {
            const interestCategory = company.intelligence?.interest_category || 'low';
            const interestLevel = company.intelligence?.interest_level || 0;
            const changeLevel = getCompanyChangeLevel(company.company);
            
            graphData.nodes.push({
                id: company.company,
                name: company.company,
                group: company.type,
                color: CONFIG.interestColors[interestCategory],
                val: interestLevel * 3,
                interestLevel: interestLevel,
                changeLevel: changeLevel,
                shortDescription: `Interest Score: ${interestLevel}/10`
            });
            
            graphData.links.push({
                source: `interest-${interestCategory}`,
                target: company.company,
                color: CONFIG.interestColors[interestCategory],
                particles: interestLevel > 5 ? 4 : 2,
                width: interestLevel / 5
            });
        });
    }

    // Handle node hover with rich information
    function handleNodeHover(node) {
        if (!node) {
            document.getElementById('node-info').innerHTML = 'Right-click on nodes to focus on subgraph';
            return;
        }
        
        let infoHtml = `<strong style="color: ${node.color}">${node.name}</strong><br/>`;
        infoHtml += `Type: ${node.group}<br/>`;
        
        if (node.changeLevel > 0) {
            const changeColor = getChangeColor(node.changeLevel);
            infoHtml += `<span style="color: ${changeColor}">Recent Change Level: ${node.changeLevel}/10</span><br/>`;
        }
        
        if (node.products && node.products.length > 0) {
            infoHtml += `<br/><strong>Products:</strong><br/>`;
            infoHtml += node.products.map(p => 
                `â€¢ <span class="entity-link" onclick="searchEntity('${p}')">${p}</span>`
            ).join('<br/>');
        }
        
        if (node.technologies && node.technologies.length > 0) {
            infoHtml += `<br/><strong>Technologies:</strong><br/>`;
            infoHtml += node.technologies.map(t => 
                `â€¢ <span class="entity-link" onclick="searchEntity('${t}')">${t}</span>`
            ).join('<br/>');
        }
        
        if (node.concepts && node.concepts.length > 0) {
            infoHtml += `<br/><strong>AI/ML Focus:</strong><br/>`;
            infoHtml += node.concepts.map(c => 
                `â€¢ <span class="entity-link" onclick="searchEntity('${c}')">${c}</span>`
            ).join('<br/>');
        }
        
        if (node.companies) {
            infoHtml += `<br/><strong>Related Companies:</strong><br/>`;
            infoHtml += node.companies.slice(0, 5).map(c => 
                `â€¢ <span class="entity-link" onclick="focusOnNode('${c}')">${c}</span>`
            ).join('<br/>');
            if (node.companies.length > 5) {
                infoHtml += `<br/>... and ${node.companies.length - 5} more`;
            }
        }
        
        document.getElementById('node-info').innerHTML = infoHtml;
    }

    // Handle node click - focus and zoom
    function handleNodeClick(node) {
        selectedNode = node;
        const distance = 200;
        const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);
        
        Graph.cameraPosition(
            { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio },
            node,
            3000
        );
        
        // Highlight connected nodes
        const highlightNodes = new Set();
        const highlightLinks = new Set();
        
        if (node) {
            highlightNodes.add(node);
            graphData.links.forEach(link => {
                if (link.source.id === node.id || link.target.id === node.id) {
                    highlightLinks.add(link);
                    highlightNodes.add(link.source);
                    highlightNodes.add(link.target);
                }
            });
        }
        
        // Update node colors based on highlight
        graphData.nodes.forEach(n => {
            if (highlightNodes.has(n)) {
                n.__originalColor = n.color;
                n.color = '#00ff88';
            } else if (n.__originalColor) {
                n.color = n.__originalColor;
                delete n.__originalColor;
            }
        });
        
        Graph.nodeColor(Graph.nodeColor());
    }

    // Handle right click - show context menu
    function handleNodeRightClick(node, event) {
        event.preventDefault();
        selectedNode = node;
        
        const menu = document.getElementById('contextMenu');
        menu.style.display = 'block';
        menu.style.left = event.pageX + 'px';
        menu.style.top = event.pageY + 'px';
    }

    // Hide context menu
    function hideContextMenu() {
        document.getElementById('contextMenu').style.display = 'none';
    }

    // Focus on subgraph
    function focusOnSubgraph() {
        if (!selectedNode) return;
        
        const connectedNodes = new Set();
        const connectedLinks = [];
        
        // Find all connected nodes
        connectedNodes.add(selectedNode);
        
        graphData.links.forEach(link => {
            if (link.source.id === selectedNode.id || link.target.id === selectedNode.id) {
                connectedNodes.add(link.source);
                connectedNodes.add(link.target);
                connectedLinks.push(link);
            }
        });
        
        // Create filtered graph data
        const filteredNodes = Array.from(connectedNodes);
        
        // Update the graph
        Graph.graphData({ nodes: filteredNodes, links: connectedLinks });
        
        hideContextMenu();
    }

    // Show all connections for selected node
    function showAllConnections() {
        if (!selectedNode) return;
        
        // Find all nodes connected through secondary connections
        const connectedNodes = new Set();
        const connectedLinks = [];
        
        // First level connections
        connectedNodes.add(selectedNode);
        const firstLevel = new Set();
        
        graphData.links.forEach(link => {
            if (link.source.id === selectedNode.id || link.target.id === selectedNode.id) {
                connectedNodes.add(link.source);
                connectedNodes.add(link.target);
                firstLevel.add(link.source);
                firstLevel.add(link.target);
                connectedLinks.push(link);
            }
        });
        
        // Second level connections
        firstLevel.forEach(node => {
            graphData.links.forEach(link => {
                if (link.source.id === node.id || link.target.id === node.id) {
                    connectedNodes.add(link.source);
                    connectedNodes.add(link.target);
                    connectedLinks.push(link);
                }
            });
        });
        
        // Update the graph
        const filteredNodes = Array.from(connectedNodes);
        Graph.graphData({ nodes: filteredNodes, links: connectedLinks });
        
        hideContextMenu();
    }

    // Hide selected node
    function hideNode() {
        if (!selectedNode) return;
        
        hiddenNodes.add(selectedNode.id);
        
        const filteredNodes = graphData.nodes.filter(n => !hiddenNodes.has(n.id));
        const filteredLinks = graphData.links.filter(l => 
            !hiddenNodes.has(l.source.id || l.source) && 
            !hiddenNodes.has(l.target.id || l.target)
        );
        
        Graph.graphData({ nodes: filteredNodes, links: filteredLinks });
        
        hideContextMenu();
    }

    // Reset view to full graph
    function resetView() {
        hiddenNodes.clear();
        Graph.graphData(fullGraphData);
        Graph.cameraPosition({ x: 0, y: 0, z: 500 });
        hideContextMenu();
    }

    // Search for entity and focus on it
    window.searchEntity = function(entityName) {
        const node = graphData.nodes.find(n => 
            n.name === entityName || 
            n.id === `tech-${entityName}` || 
            n.id === `concept-${entityName}`
        );
        
        if (node) {
            handleNodeClick(node);
        }
    };

    // Focus on specific node by ID
    window.focusOnNode = function(nodeId) {
        const node = graphData.nodes.find(n => n.id === nodeId);
        if (node) {
            handleNodeClick(node);
        }
    };

    // Update statistics
    function updateStats() {
        if (!rawData.dashboard) return;
        
        const stats = rawData.dashboard.stats;
        const recentChanges = rawData.changes?.changes?.length || 0;
        
        document.getElementById('statsContent').innerHTML = `
            <strong>Monitoring Stats:</strong><br/>
            Companies: ${stats.companies}<br/>
            URLs: ${stats.urls}<br/>
            Snapshots: ${stats.snapshots}<br/>
            Recent Changes: ${recentChanges}<br/>
            Graph Nodes: ${graphData.nodes.length}<br/>
            Graph Links: ${graphData.links.length}
        `;
    }

    // Event handlers for enhanced controls
    
    // Force strength slider
    document.getElementById('forceSlider').addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        document.getElementById('forceValue').textContent = value;
        if (Graph) {
            Graph.d3Force('charge').strength(value);
            Graph.d3ReheatSimulation();
        }
    });
    
    // Link distance slider
    document.getElementById('linkDistanceSlider').addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        document.getElementById('linkDistanceValue').textContent = value;
        if (Graph) {
            Graph.d3Force('link').distance(value);
            Graph.d3ReheatSimulation();
        }
    });
    
    // Font size slider
    document.getElementById('fontSizeSlider').addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        document.getElementById('fontSizeValue').textContent = value;
        CONFIG.fontSize = value;
        
        // Update all text sprites
        if (Graph) {
            graphData.nodes.forEach(node => {
                const obj = Graph.nodeThreeObject(node);
                if (obj && obj.children) {
                    obj.children.forEach(child => {
                        if (child.isSprite) {
                            child.textHeight = CONFIG.fontSize;
                        }
                    });
                }
            });
        }
    });
    
    // View mode selector
    document.getElementById('viewMode').addEventListener('change', (e) => {
        currentView = e.target.value;
        switch(currentView) {
            case 'technologies':
                buildTechnologyView();
                break;
            case 'interests':
                buildInterestView();
                break;
            case 'companies':
            default:
                buildCompanyNetwork();
                break;
        }
        if (Graph) {
            Graph.graphData(graphData);
            updateStats();
        }
    });
    
    // Filter type selector
    document.getElementById('filterType').addEventListener('change', (e) => {
        const filterType = e.target.value;
        if (filterType === 'all') {
            buildCompanyNetwork();
        } else if (filterType === 'none') {
            // Show only AI concept nodes (no companies)
            const conceptNodes = graphData.nodes.filter(node => 
                node.group === 'AI Concept'
            );
            Graph.graphData({ nodes: conceptNodes, links: [] });
        } else {
            const filteredNodes = graphData.nodes.filter(node => 
                node.group === filterType || node.group === 'AI Concept'
            );
            const nodeIds = new Set(filteredNodes.map(n => n.id));
            const filteredLinks = graphData.links.filter(link =>
                nodeIds.has(link.source.id || link.source) && 
                nodeIds.has(link.target.id || link.target)
            );
            
            Graph.graphData({ nodes: filteredNodes, links: filteredLinks });
        }
        updateStats();
    });
    
    // Node display mode toggles
    document.getElementById('nodeSimple').addEventListener('click', () => {
        nodeDisplayMode = 'simple';
        document.getElementById('nodeSimple').classList.add('active');
        document.getElementById('nodeRich').classList.remove('active');
        
        // Rebuild the graph with new node type
        if (Graph) {
            const cameraPos = Graph.cameraPosition();
            Graph.graphData(graphData);
            Graph.cameraPosition(cameraPos, { x: 0, y: 0, z: 0 });
        }
    });
    
    document.getElementById('nodeRich').addEventListener('click', () => {
        nodeDisplayMode = 'rich';
        document.getElementById('nodeRich').classList.add('active');
        document.getElementById('nodeSimple').classList.remove('active');
        
        // Rebuild the graph with new node type
        if (Graph) {
            const cameraPos = Graph.cameraPosition();
            Graph.graphData(graphData);
            Graph.cameraPosition(cameraPos, { x: 0, y: 0, z: 0 });
        }
    });
    
    // Toggle particles
    document.getElementById('toggleParticles').addEventListener('click', function() {
        particlesEnabled = !particlesEnabled;
        this.classList.toggle('active');
        
        if (Graph) {
            graphData.links.forEach(link => {
                Graph.linkDirectionalParticles(link, particlesEnabled ? link.particles || 2 : 0);
            });
        }
    });
    
    // Toggle labels
    document.getElementById('toggleLabels').addEventListener('click', function() {
        labelsEnabled = !labelsEnabled;
        this.classList.toggle('active');
        
        // Update node visibility
        if (Graph) {
            graphData.nodes.forEach(node => {
                const obj = Graph.nodeThreeObject(node);
                if (obj && obj.children) {
                    obj.children.forEach(child => {
                        if (child.isSprite) {
                            child.visible = labelsEnabled;
                        }
                    });
                }
            });
        }
    });
    
    // Toggle links
    document.getElementById('toggleLinks').addEventListener('click', function() {
        linksEnabled = !linksEnabled;
        this.classList.toggle('active');
        
        if (Graph) {
            Graph.linkOpacity(linksEnabled ? CONFIG.linkOpacity : 0);
            Graph.linkWidth(link => linksEnabled ? (link.width || CONFIG.linkWidth) : 0);
        }
    });
    
    // Toggle change rings
    document.getElementById('toggleChangeRings').addEventListener('click', function() {
        changeRingsEnabled = !changeRingsEnabled;
        this.classList.toggle('active');
        
        // Recreate nodes with/without change rings
        if (Graph) {
            const cameraPos = Graph.cameraPosition();
            Graph.graphData(graphData);
            Graph.cameraPosition(cameraPos, { x: 0, y: 0, z: 0 });
        }
    });
    
    // Context menu handlers
    document.getElementById('focusSubgraph').addEventListener('click', focusOnSubgraph);
    document.getElementById('showAllConnections').addEventListener('click', showAllConnections);
    document.getElementById('hideNode').addEventListener('click', hideNode);
    document.getElementById('resetView').addEventListener('click', resetView);
    
    // Hide context menu on click outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('#contextMenu')) {
            hideContextMenu();
        }
    });
    
    // Initialize on load
    window.addEventListener('load', () => {
        console.log('Page loaded, initializing graph...');
        initGraph();
    });
    
    // Animation loop for rotating elements
    function animate() {
        requestAnimationFrame(animate);
        
        if (Graph) {
            graphData.nodes.forEach(node => {
                const obj = Graph.nodeThreeObject(node);
                if (obj && obj.children) {
                    obj.children.forEach(child => {
                        if (child.userData.update) {
                            child.userData.update();
                        }
                    });
                }
            });
        }
    }
    animate();
    </script>
</body>
</html>